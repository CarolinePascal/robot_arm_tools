load "msh3"
load "tetgen"
load "medit"
load "mmg"
include "MeshSurface.idp"
load "lapack"

func meshS meshSphere(real radius, real resolution)
{
    // Mesh 2D
    mesh Th = square(10, 20, [x*pi-pi/2, 2*y*pi]); // ]-pi/2, pi/2[X]0, 2pi[

    // A parametrization of a sphere
    func f1 = radius*cos(x)*cos(y);
    func f2 = radius*cos(x)*sin(y);
    func f3 = radius*sin(x);
    // Partial derivative of the parametrization DF
    func f1x = radius*sin(x)*cos(y);
    func f1y = radius*-cos(x)*sin(y);
    func f2x = radius*-sin(x)*sin(y);
    func f2y = radius*cos(x)*cos(y);
    func f3x = radius*cos(x);
    func f3y = 0;
    //M = DF^t DF
    func m11 = f1x^2 + f2x^2 + f3x^2;
    func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
    func m22 = f1y^2 + f2y^2 + f3y^2;

    // Periodic condition
    func perio = [[4, y], [2, y], [1, x], [3, x]];

    // Mesh adaptation
    real vv = 1/(resolution*resolution);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);

    // Sphere
    meshS Th3 = movemesh23(Th, transfo=[f1, f2, f3]);

    if(radius/resolution >= 25)
    {
        Th3 = mmgs(Th3,hmin=resolution,hmax=resolution,hgrad=2.0);
    }

    return(Th3);
}

func meshS meshSphereOrdered(real radius, int angularVerticesNumber, int borderLabel)
{
    int halfVerticesNumber = 0;
    
    if(angularVerticesNumber%2 != 0)
    {
        halfVerticesNumber = (angularVerticesNumber + 1)/2;   
    }
    else
    {
        halfVerticesNumber = angularVerticesNumber/2;
    }

    border exteriorCircle(t = -pi/2,pi/2){x = 1.5*radius*cos(t); y = 1.5*radius*sin(t); label = borderLabel + 1;}
    border radialLink1(t = 1.5*radius,radius){x = 0; y = t; label = borderLabel + 1;} 
    border interiorCircle(t = pi/2,-pi/2){x = radius*cos(t); y = radius*sin(t); label = borderLabel;}
    border radialLink2(t = radius,1.5*radius){x = 0; y = -t; label = borderLabel + 1;} 
    
    mesh Th2d = buildmesh(exteriorCircle(halfVerticesNumber) + radialLink1(1) + interiorCircle(halfVerticesNumber) + radialLink2(1), fixedborder=true);

    func fx = x*cos(z);
    func fy = x*sin(z);
    func fz = y;  
    mesh3 Th3d = buildlayers(Th2d, angularVerticesNumber, zbound=[0, 2*pi], transfo=[fx, fy, fz]);
    
    int[int] lab = [borderLabel];
    return(extract(Th3d,label=lab));
}

func int planeCutPoints(real radius, real[int] planeNormal, int pointsNumber, real[int] X, real[int] Y, real[int] Z)
{
    real[int] planeTangent1(3);

    for(int i = 0; i < 3; i++)
    {
        if(planeNormal[i] != 0)
        {
            planeTangent1[(i+1)%3] = planeNormal[i];
            planeTangent1[i] = -planeNormal[(i+1)%3];
            break;
        }
    }

    planeTangent1 = planeTangent1/sqrt(planeTangent1[0]*planeTangent1[0] + planeTangent1[1]*planeTangent1[1] + planeTangent1[2]*planeTangent1[2]);
    real[int] planeTangent2 = [planeNormal[1]*planeTangent1[2] - planeNormal[2]*planeTangent1[1],
                               planeNormal[2]*planeTangent1[0] - planeNormal[0]*planeTangent1[2],
                               planeNormal[0]*planeTangent1[1] - planeNormal[1]*planeTangent1[0]];

    real[int, int] B = [[planeTangent1[0],planeTangent2[0],planeNormal[0]],
                        [planeTangent1[1],planeTangent2[1],planeNormal[1]],
                        [planeTangent1[2],planeTangent2[2],planeNormal[2]]];

    real[int, int] Binv = B^-1;

    for(int i = 0; i < pointsNumber; i++)
    {
        real[int, int] Rz = [[cos(i*2*pi/pointsNumber),-sin(i*2*pi/pointsNumber),0],
                             [sin(i*2*pi/pointsNumber),cos(i*2*pi/pointsNumber),0],
                             [0,0,1]];

        real[int, int] RzB = Rz*Binv;
        real[int, int] BRzB = B*RzB;

        real[int] XYZ = BRzB*planeTangent1;

        X[i] = radius*XYZ[0];
        Y[i] = radius*XYZ[1];
        Z[i] = radius*XYZ[2];    
    }

    return(0);
}