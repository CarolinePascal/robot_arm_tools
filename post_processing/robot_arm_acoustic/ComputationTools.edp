//Spherical coordinates functions
func r = sqrt(x*x + y*y + z*z);
func theta = atan2(sqrt(x*x + y*y),z);
func phi = atan2(y,x); 

func normalx = sin(theta)*cos(phi);
func normaly = sin(theta)*sin(phi);
func normalz = cos(theta);

func real[int] logspace(real minPow, real maxPow, int itemNumber)
{
    real delta = (maxPow - minPow)/(itemNumber-1);
    real[int] output(itemNumber);

    for (int i = 0; i < itemNumber; i++)
    {
        output[i] = pow(10,minPow+i*delta);
    }

    return(output);
}

func real[int] linspace(real min, real max, int itemNumber)
{
    real delta = (max - min)/(itemNumber-1);
    real[int] output(itemNumber);

    for (int i = 0; i < itemNumber; i++)
    {
        output[i] = min+i*delta;
    }

    return(output);
}

//TODO Run the meshing tool if mesh is missing ?
func meshS getSphericMesh(real size, real resolution, real sigma, string elementType)
{
    //Solve rounding issues...
    string sizeWithDecimal;
    if(size - floor(size) > 0)
    {
        sizeWithDecimal = size;
    }
    else
    {
        sizeWithDecimal = size + ".0";
    }

    string resolutionWithDecimal;
    if(resolution - floor(resolution) > 0)
    {
        resolutionWithDecimal = resolution;
    }
    else
    {
        resolutionWithDecimal = resolution + ".0";
    }

    string sigmaWithDecimal;
    if(resolution - floor(resolution) > 0)
    {
        sigmaWithDecimal = sigma;
    }
    else
    {
        sigmaWithDecimal = sigma + ".0";
    }

    //Load mesh
    if(sigma == 0.0)
    {
        meshS ThS("./meshes/sphere/" + elementType + "/" + sizeWithDecimal + "_" + resolutionWithDecimal + ".mesh");
        ThS = OrientNormal(ThS,unbounded=1);
        return(ThS);
    }
    else
    {
        meshS ThS("./meshes/sphere_uncertainty/" + elementType + "/" + sizeWithDecimal + "_" + resolutionWithDecimal + "_" + sigmaWithDecimal + ".mesh");
        ThS = OrientNormal(ThS,unbounded=1);
        return(ThS); 
    }

}

func meshL getCircularMesh(real size, real resolution, real sigma, string elementType)
{
    //Solve rounding issues...
    string sizeWithDecimal;
    if(size - floor(size) > 0)
    {
        sizeWithDecimal = size;
    }
    else
    {
        sizeWithDecimal = size + ".0";
    }

    string resolutionWithDecimal;
    if(resolution - floor(resolution) > 0)
    {
        resolutionWithDecimal = resolution;
    }
    else
    {
        resolutionWithDecimal = resolution + ".0";
    }

    string sigmaWithDecimal;
    if(resolution - floor(resolution) > 0)
    {
        sigmaWithDecimal = sigma;
    }
    else
    {
        sigmaWithDecimal = sigma + ".0";
    }

    //Load mesh
    if(sigma == 0.0)
    {
        meshL ThL("./meshes/circle/" + elementType + "/" + sizeWithDecimal + "_" + resolutionWithDecimal + ".mesh");
        return(ThL);
    }
    else
    {
        meshL ThL("./meshes/circle_uncertainty/" + elementType + "/" + sizeWithDecimal + "_" + resolutionWithDecimal + "_" + sigmaWithDecimal + ".mesh");
        return(ThL); 
    }

}

func mesh getPrettyMesh(real radius, real resolution)
{
    int n = ceil(3*radius/resolution);

    border b0(t = 0, 2*pi){x=radius*cos(t); y=radius*sin(t); z=0;}
    border b1(t=-3*radius, 3*radius){x=t; y=-3*radius; z=0;}
    border b2(t=-3*radius, 3*radius){x=3*radius; y=t; z=0;}
    border b3(t=-3*radius, 3*radius){x=-t; y=3*radius; z=0;}
    border b4(t=-3*radius, 3*radius){x=-3*radius; y=-t; z=0;}

    mesh outputMesh = buildmesh(b1(n)+b2(n)+b3(n)+b4(n)+b0(-n));

    return(outputMesh);
}