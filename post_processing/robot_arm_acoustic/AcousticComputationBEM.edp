load "bem"
load "shell"
load "iovtk"
load "medit"
load "msh3"

load "gsl"
gslrng ffrng;

include "ComputationTools.edp"
include "AcousticTools.edp"
include "MeasurementsTools.edp"

include "getARGV.idp"

verbosity = 0;

htoolEpsilon = 1e-6;
htoolEta = 1;
htoolMinclustersize = 100;
htoolMaxblocksize = 1000000;

//Element type macro must be defined here for compilation purposes 

IFMACRO(!elementType)
func Pk = P0;
string elementTypeName = "P0";
ENDIFMACRO
IFMACRO(elementType)
func Pk = elementType;
string elementTypeName = Stringification(elementType);
ENDIFMACRO

IFMACRO(!gradient)
bool computeGradient = false;
func PkVerification = P1;
string elementTypeNameVerification = "P1";
ENDIFMACRO
IFMACRO(gradient,0)
bool computeGradient = false;
func PkVerification = P1;
string elementTypeNameVerification = "P1";
ENDIFMACRO
IFMACRO(gradient,1)
bool computeGradient = true;
func PkVerification = Pk;
string elementTypeNameVerification = elementTypeName;
ENDIFMACRO

func int AcousticSL(real frequency, meshS &measurementsMesh, complex[int] measurementsData, meshS &verificationMesh, complex[int] verificationData, string outputFileName, complex[int] verificationDataGradient, string outputFileNameGradient, string outputFolder, real physicsFactor)
{
    //Define the variational problem
    BemKernel ker("SL",k=physicsFactor*k(frequency));
    varf vbem(u,v) = int2dx2d(measurementsMesh)(measurementsMesh)(BEM(ker,u,v)) ;  

    //Assemble the H-Matrix
    fespace Uh(measurementsMesh,Pk);
    HMatrix<complex> H = vbem(Uh,Uh);

    //Retrieve measurements
    Uh<complex> measurements;
    measurements[] = measurementsData;

    //Solve the linear system
    Uh<complex> p, b;
    varf vrhs(u,v) = int2d(measurementsMesh)(measurements*v);
    b[] = vrhs(0,Uh);
    p[] = H^-1*b[];

    //Compute the numerical solution
    BemPotential Pot("SL",k=physicsFactor*k(frequency));
    varf vpot(u,v) = int2d(measurementsMesh)(POT(Pot,u,v));

    //Evaluate the solution on the verification points
    fespace UhOut(verificationMesh,PkVerification);

    HMatrix<complex> HP = vpot(Uh,UhOut);
    UhOut<complex> uN;
    uN[] = HP*p[];

    //Compute the analytical solution
    UhOut<complex> uA;
    uA[] = verificationData;

    //DEBUG
    if(mpirank == 0)
    {
        real l2Error = sqrt(int2d(verificationMesh)(abs(uA-uN)^2))/sqrt(int2d(verificationMesh)(abs(uA)^2));
        cout << "L2 ERROR SL (RELATIVE) : " << l2Error << endl;
        UhOut delta = abs(uA-uN);
        UhOut reference = abs(uA);
        cout << "LINF ERROR SL (RELATIVE) : " << delta[].max/reference[].max << endl;
    }

    //Fill output file
    string outputFilePath = outputFolder + "BEM_SL/" + outputFileName;
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < verificationMesh.nv; i++)
    {
        file << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    if(computeGradient)
    {
        //Define the gradient variational problem
        BemKernel kerGradient("TDL",k=physicsFactor*k(frequency));
        varf vbemGradient(u,v) = int2dx2d(measurementsMesh)(verificationMesh)(BEM(kerGradient,u,v));

        //Assemble the H-Matrix
        HMatrix<complex> HGradient = vbemGradient(Uh,UhOut);

        //Evaluate the solution on the verification points
        UhOut<complex> uNGradient, uNGradientTmp;
        uNGradientTmp[] = HGradient*p[];

        varf vmassGradient(u,v) = int2d(verificationMesh)(u*v);
        matrix<complex> massGradient = vmassGradient(UhOut,UhOut);
        uNGradient[] = massGradient^-1*uNGradientTmp[];

        //Compute the analytical solution
        UhOut<complex> uAGradient;
        uAGradient[] = verificationDataGradient;
            
        //DEBUG
        if(mpirank == 0)
        {
            real l2ErrorGradient = sqrt(int2d(verificationMesh)(abs(uAGradient-uNGradient)^2))/sqrt(int2d(verificationMesh)(abs(uAGradient)^2));
            cout << "L2 ERROR SL GRAD (RELATIVE) : " << l2ErrorGradient << endl;
            UhOut deltaGradient = abs(uAGradient-uNGradient);
            UhOut referenceGradient = abs(uAGradient);
            cout << "LINF ERROR SL GRAD (RELATIVE) : " << deltaGradient[].max/referenceGradient[].max << endl;
        }

        //Fill output file
        string outputFilePathGradient = outputFolder + "BEM_SL/" + outputFileNameGradient;
        ofstream fileGradient(outputFilePathGradient);
        int npGradient = fileGradient.precision(20);

        for (int i = 0; i < verificationMesh.nv; i++)
        {
            fileGradient << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uAGradient[][i]) << ";" << imag(uAGradient[][i]) << ";" << real(uNGradient[][i]) << ";" << imag(uNGradient[][i]) << endl;
        }
    }

    return(0);
}

func int AcousticCL(real frequency, meshS &measurementsMesh, complex[int] measurementsData, meshS &verificationMesh, complex[int] verificationData, string outputFileName, complex[int] verificationDataGradient, string outputFileNameGradient, string outputFolder, real physicsFactor)
{
    //Define the variational problem
    BemKernel kerSL("SL",k=physicsFactor*k(frequency));
    BemKernel kerDL("DL",k=physicsFactor*k(frequency));
    BemKernel ker=(-physicsFactor*k(frequency)*1i)*kerSL+kerDL;
    varf vbem(u,v)=int2dx2d(measurementsMesh)(measurementsMesh)(BEM(ker,u,v)) + int2d(measurementsMesh)(0.5*u*v); 

    //Assemble the H-Matrix
    fespace Uh(measurementsMesh,Pk);
    HMatrix<complex> H = vbem(Uh,Uh);

    //Retrieve measurements
    Uh<complex> measurements;
    measurements[] = measurementsData;

    //Solve the linear system
    Uh<complex> p, b;
    varf vrhs(u,v) = int2d(measurementsMesh)(measurements*v);
    b[] = vrhs(0,Uh);
    p[] = H^-1*b[];

    //Compute the numerical solution
    BemPotential PotSL("SL",k=physicsFactor*k(frequency));
    varf vpotSL(u,v) = int2d(measurementsMesh)(POT(PotSL,u,v));
    BemPotential PotDL("DL",k=physicsFactor*k(frequency));
    varf vpotDL(u,v) = int2d(measurementsMesh)(POT(PotDL,u,v));

    //Evaluate the solution on the verification points
    fespace UhOut(verificationMesh,PkVerification);

    HMatrix<complex> HPSL = vpotSL(Uh,UhOut);
    HMatrix<complex> HPDL = vpotDL(Uh,UhOut);
    UhOut<complex> uN,uSL,uDL;
    uSL[] = HPSL*p[];
    uDL[] = HPDL*p[];
    uN = (-physicsFactor*k(frequency)*1i)*uSL + uDL;

    //Compute the analytical solution
    UhOut<complex> uA;
    uA[] = verificationData;

    //DEBUG
    if(mpirank == 0)
    {
        real l2Error = sqrt(int2d(verificationMesh)(abs(uA-uN)^2))/sqrt(int2d(verificationMesh)(abs(uA)^2));
        cout << "L2 ERROR CL (RELATIVE) : " << l2Error << endl;
        UhOut delta = abs(uA-uN);
        UhOut reference = abs(uA);
        cout << "LINF ERROR CL (RELATIVE) : " << delta[].max/reference[].max << endl;
    }

    //Fill output file
    string outputFilePath = outputFolder + "BEM_CL/" + outputFileName;
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < verificationMesh.nv; i++)
    {
        file << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    if(computeGradient)
    {
        if(elementTypeName == "P0")
        {
            cout << "Impossible combination of P0 elements and HS operator !" << endl;
            return(-1);
        }

        //Define the gradient variational problem
        BemKernel kerGradientSL("TDL",k=physicsFactor*k(frequency));
        BemKernel kerGradientDL("HS",k=physicsFactor*k(frequency));   //Does not work with P0 (becomes equivalent to SL) !
        BemKernel kerGradient=(-physicsFactor*k(frequency)*1i)*kerGradientSL+kerGradientDL;
        varf vbemGradient(u,v) = int2dx2d(measurementsMesh)(measurementsMesh)(BEM(kerGradient,u,v));

        //Assemble the H-Matrix
        HMatrix<complex> HGradient = vbemGradient(Uh,UhOut);

        //Evaluate the solution on the verification points
        UhOut<complex> uNGradient, uNGradientTmp;
        uNGradientTmp[] = HGradient*p[];

        varf vmassGradient(u,v) = int2d(verificationMesh)(u*v);
        matrix<complex> massGradient = vmassGradient(UhOut,UhOut);
        uNGradient[] = massGradient^-1*uNGradientTmp[];

        //Compute the analytical solution
        UhOut<complex> uAGradient;
        uAGradient[] = verificationDataGradient;
            
        //DEBUG
        if(mpirank == 0)
        {
            real l2ErrorGradient = sqrt(int2d(verificationMesh)(abs(uAGradient-uNGradient)^2))/sqrt(int2d(verificationMesh)(abs(uAGradient)^2));
            cout << "L2 ERROR CL GRAD (RELATIVE) : " << l2ErrorGradient << endl;
            UhOut deltaGradient = abs(uAGradient-uNGradient);
            UhOut referenceGradient = abs(uAGradient);
            cout << "LINF ERROR CL GRAD (RELATIVE) : " << deltaGradient[].max/referenceGradient[].max << endl;
        }

        //Fill output file
        string outputFilePathGradient = outputFolder + "BEM_CL/" + outputFileNameGradient;
        ofstream fileGradient(outputFilePathGradient);
        int npGradient = fileGradient.precision(20);

        for (int i = 0; i < verificationMesh.nv; i++)
        {
            fileGradient << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uAGradient[][i]) << ";" << imag(uAGradient[][i]) << ";" << real(uNGradient[][i]) << ";" << imag(uNGradient[][i]) << endl;
        }
    }

    return(0);
}

func int AcousticSL(real frequency, meshS &measurementsMesh, complex[int] measurementsData, meshL &verificationMesh, complex[int] verificationData, string outputFileName, string outputFolder, real physicsFactor)
{
    //Define the variational problem
    BemKernel ker("SL",k=physicsFactor*k(frequency));
    varf vbem(u,v) = int2dx2d(measurementsMesh)(measurementsMesh)(BEM(ker,u,v)) ;  

    //Assemble the H-Matrix
    fespace Uh(measurementsMesh,Pk);
    HMatrix<complex> H = vbem(Uh,Uh);

    //Retrieve measurements
    Uh<complex> measurements;
    measurements[] = measurementsData;

    //Solve the linear system
    Uh<complex> p, b;
    varf vrhs(u,v) = int2d(measurementsMesh)(measurements*v);
    b[] = vrhs(0,Uh);
    p[] = H^-1*b[];

    //Compute the numerical solution
    BemPotential Pot("SL",k=physicsFactor*k(frequency));
    varf vpot(u,v) = int2d(measurementsMesh)(POT(Pot,u,v));

    //Evaluate the solution on the verification points
    fespace UhOut(verificationMesh,P1);

    HMatrix<complex> HP = vpot(Uh,UhOut);
    UhOut<complex> uN;
    uN[] = HP*p[];

    //Compute the analytical solution
    UhOut<complex> uA;
    uA[] = verificationData;

    //DEBUG
    if(mpirank == 0)
    {
        real l2Error = sqrt(int1d(verificationMesh)(abs(uA-uN)^2))/sqrt(int1d(verificationMesh)(abs(uA)^2));
        cout << "L2 ERROR SL (RELATIVE) : " << l2Error << endl;
        UhOut delta = abs(uA-uN);
        UhOut reference = abs(uA);
        cout << "LINF ERROR SL (RELATIVE) : " << delta[].max/reference[].max << endl;
    }

    //Fill output file
    string outputFilePath = outputFolder + "BEM_SL/" + outputFileName;
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < verificationMesh.nv; i++)
    {
        file << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

func int AcousticCL(real frequency, meshS &measurementsMesh, complex[int] measurementsData, meshL &verificationMesh, complex[int] verificationData, string outputFileName, string outputFolder, real physicsFactor)
{
    //Define the variational problem
    BemKernel kerSL("SL",k=physicsFactor*k(frequency));
    BemKernel kerDL("DL",k=physicsFactor*k(frequency));
    BemKernel ker=(-physicsFactor*k(frequency)*1i)*kerSL+kerDL;
    varf vbem(u,v)=int2dx2d(measurementsMesh)(measurementsMesh)(BEM(ker,u,v)) + int2d(measurementsMesh)(0.5*u*v); 

    //Assemble the H-Matrix
    fespace Uh(measurementsMesh,Pk);
    HMatrix<complex> H = vbem(Uh,Uh);

    //Retrieve measurements
    Uh<complex> measurements;
    measurements[] = measurementsData;

    //Solve the linear system
    Uh<complex> p, b;
    varf vrhs(u,v) = int2d(measurementsMesh)(measurements*v);
    b[] = vrhs(0,Uh);
    p[] = H^-1*b[];

    //Compute the numerical solution
    BemPotential PotSL("SL",k=physicsFactor*k(frequency));
    varf vpotSL(u,v) = int2d(measurementsMesh)(POT(PotSL,u,v));
    BemPotential PotDL("DL",k=physicsFactor*k(frequency));
    varf vpotDL(u,v) = int2d(measurementsMesh)(POT(PotDL,u,v));

    //Evaluate the solution on the verification points
    fespace UhOut(verificationMesh,P1);

    HMatrix<complex> HPSL = vpotSL(Uh,UhOut);
    HMatrix<complex> HPDL = vpotDL(Uh,UhOut);
    UhOut<complex> uN,uSL,uDL;
    uSL[] = HPSL*p[];
    uDL[] = HPDL*p[];
    uN = (-physicsFactor*k(frequency)*1i)*uSL + uDL;

    //Compute the analytical solution
    UhOut<complex> uA;
    uA[] = verificationData;

    //DEBUG
    if(mpirank == 0)
    {
        real l2Error = sqrt(int1d(verificationMesh)(abs(uA-uN)^2))/sqrt(int1d(verificationMesh)(abs(uA)^2));
        cout << "L2 ERROR CL (RELATIVE) : " << l2Error << endl;
        UhOut delta = abs(uA-uN);
        UhOut reference = abs(uA);
        cout << "LINF ERROR CL (RELATIVE) : " << delta[].max/reference[].max << endl;
    }

    //Fill output file
    string outputFilePath = outputFolder + "BEM_CL/" + outputFileName;
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < verificationMesh.nv; i++)
    {
        file << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

//MAIN

//Global parameters
int realMeasurements = getARGV("-realMeasurements",0);

//Because the physics convention is different from the mathematical one...
real physicsFactor = 1.0;
if(realMeasurements == 1)
{
    physicsFactor = -1.0;
}

real frequency = getARGV("-frequency",100); 

string fileID = getARGV("-fileID","");
if(fileID != "")
{
    fileID = "_" + fileID;
}

//Real measurements
if(realMeasurements == 1)
{
    //Real measurements parameters
    string measurementsMeshPath = getARGV("-measurementsMeshPath","");
    string measurementsDataPath = getARGV("-measurementsDataPath",""); 
    string verificationMeshPath = getARGV("-verificationMeshPath","");
    string verificationDataPath = getARGV("-verificationDataPath",""); 

    string outputFolder = dirname(measurementsDataPath) + "/";

    if(isdir(outputFolder + "BEM_SL") == -1)
    {
        mkdir(outputFolder + "BEM_SL");
    }
    if(isdir(outputFolder + "BEM_CL") == -1)
    {
        mkdir(outputFolder + "BEM_CL");
    }

    //TODO
    //if(computeGradient == 1)
    //{
        //string verificationGradientDataPath = getARGV("-verificationGradientDataPath"); 
    //}

    //TODO interolate/extrapolate P0/P1 elements
    string outputFileName = elementTypeName + "/output_" + frequency + fileID + ".csv";
    string outputFileNameGradient = elementTypeName + "/gradient/output_" + frequency + fileID + ".csv";

    if(isdir(outputFolder + "BEM_SL/" + elementTypeName) == -1)
    {
        mkdir(outputFolder + "BEM_SL/" + elementTypeName);
        if(computeGradient && isdir(outputFolder + "BEM_SL/" + elementTypeName + "/gradient") == -1)
        {
            mkdir(outputFolder + "BEM_SL/" + elementTypeName + "/gradient");
        }
    }
    if(isdir(outputFolder + "BEM_CL/" + elementTypeName) == -1)
    {
        mkdir(outputFolder + "BEM_CL/" + elementTypeName);
        if(computeGradient && isdir(outputFolder + "BEM_CL/" + elementTypeName + "/gradient") == -1)
        {
            mkdir(outputFolder + "BEM_CL/" + elementTypeName + "/gradient");
        }
    }

    meshS measurementsMesh(measurementsMeshPath);
    measurementsMesh = OrientNormal(measurementsMesh,unbounded=1);
    complex[int] measurementsData = getData(measurementsDataPath);

    if(computeGradient)
    {
        cout << "Gradient computation for real measured data : not implemented yet, will not return a valid error value !" << endl;

        meshS verificationMesh(verificationMeshPath);
        verificationMesh = OrientNormal(verificationMesh,unbounded=0);
        complex[int] verificationData = getData(verificationDataPath);  

        //TODO !
        //complex[int] verificationDataGradient = getData(verificationGradientDataPath);  
        complex[int] verificationDataGradient(verificationData.n);

        AcousticSL(frequency, measurementsMesh, measurementsData, verificationMesh, verificationData, outputFileName, verificationDataGradient, outputFileNameGradient, outputFolder, physicsFactor);
        AcousticCL(frequency, measurementsMesh, measurementsData, verificationMesh, verificationData, outputFileName, verificationDataGradient, outputFileNameGradient, outputFolder, physicsFactor);
    }
    else
    {
        meshL verificationMesh(verificationMeshPath);
        verificationMesh = OrientNormal(verificationMesh,unbounded=0);
        complex[int] verificationData = getData(verificationDataPath);  

        AcousticSL(frequency, measurementsMesh, measurementsData, verificationMesh, verificationData, outputFileName, outputFolder, physicsFactor);
        AcousticCL(frequency, measurementsMesh, measurementsData, verificationMesh, verificationData, outputFileName, outputFolder, physicsFactor);
    }
}

//Simulation
else
{
    if(isdir("./BEM_SL") == -1)
    {
        mkdir("./BEM_SL");
    }
    if(isdir("./BEM_CL") == -1)
    {
        mkdir("./BEM_CL");
    }

    //Simulation parameters
    real size = getARGV("-size",0.1); 
    real resolution = getARGV("-resolution",0.01);
    real sigmaPosition = getARGV("-sigmaPosition",0.0);
    real sigmaMeasure = getARGV("-sigmaMeasure",0.0);

    real verificationSize = getARGV("-verificationSize",0.75);
    real verificationResolution = getARGV("-verificationResolution",0.05);

    string studiedFunction = getARGV("-studiedFunction", "monopole");
    real dipoleDistance = getARGV("-dipoleDistance",0.001);
    halfDipoleDistance = dipoleDistance/2;

    string outputFileName, outputFileNameGradient;
    string intermediateFolder = studiedFunction + "_" + elementTypeName + "/";

    if(studiedFunction == "dipole")
    {
        outputFileName = intermediateFolder + "output_" + frequency + "_" + resolution + "_" + size + "_" + dipoleDistance + "_" + sigmaPosition + "_" + sigmaMeasure + fileID + ".csv";
        outputFileNameGradient = intermediateFolder + "gradient/output_" + frequency + "_" + resolution + "_" + size + "_" + dipoleDistance + "_" + sigmaPosition + "_" + sigmaMeasure + fileID + ".csv";
    }
    else
    {
        outputFileName = intermediateFolder + "output_" + frequency + "_" + resolution + "_" + size + "_" + sigmaPosition + "_" + sigmaMeasure + fileID + ".csv";
        outputFileNameGradient = intermediateFolder + "gradient/output_" + frequency + "_" + resolution + "_" + size + "_" + sigmaPosition + "_" + sigmaMeasure + fileID + ".csv";
    }

    if(isdir("./BEM_SL/" + studiedFunction + "_" + elementTypeName) == -1)
    {
        mkdir("./BEM_SL/" + studiedFunction + "_" + elementTypeName);
    }
    if(computeGradient && isdir("./BEM_SL/" + studiedFunction + "_" + elementTypeName + "/gradient") == -1)
    {
        mkdir("./BEM_SL/" + studiedFunction + "_" + elementTypeName + "/gradient");
    }

    if(isdir("./BEM_CL/" + studiedFunction + "_" + elementTypeName) == -1)
    {
        mkdir("./BEM_CL/" + studiedFunction + "_" + elementTypeName);
    }
    if(computeGradient && isdir("./BEM_CL/" + studiedFunction + "_" + elementTypeName + "/gradient") == -1)
    {
        mkdir("./BEM_CL/" + studiedFunction + "_" + elementTypeName + "/gradient");
    }

    //Retrieve simulation mesh (assumed perfect, as we can't precisely predict the robot pose error a posteriori)
    meshS measurementsMesh = getSphericMesh(size,resolution,0.0,elementTypeName);
    measurementsMesh = OrientNormal(measurementsMesh,unbounded=1);
    
    //Create simulated measurements
    fespace Uh(measurementsMesh,Pk);
    Uh<complex> measurementsData;
    
    //Noiseless position measurements
    if(sigmaPosition == 0)
    {	
	    //Equivalent to Uh<complex> measurementsData = inputFunction(frequency,studiedFunction);
        Uh<complex> noiselessMeasurementsData = inputFunction(frequency,studiedFunction);
        measurementsData[] = noiselessMeasurementsData[];
    }    

    //Noisy position measurements
    else
    {
	    //Retrieve noisy simulation mesh (random position noise)
        meshS noisyMeasurementsMesh = getSphericMesh(size,resolution,sigmaPosition,elementTypeName);
        noisyMeasurementsMesh = OrientNormal(noisyMeasurementsMesh,unbounded=1);

        //Retrieve noisy simulated measurements
        fespace UhNoise(noisyMeasurementsMesh,Pk);
        UhNoise<complex> noisyMeasurementsData = inputFunction(frequency,studiedFunction);
        measurementsData[] = noisyMeasurementsData[];
    }

    /*if(mpirank == 0)
    {
        medit("Measurements",measurementsMesh,abs(measurementsData));
    }*/

    if(sigmaMeasure != 0.0)
    {
        real modulus, phase;
        for(int i = 0; i < measurementsData.n; i++)
        {
            modulus = abs(measurementsData[][i]);
            phase = arg(measurementsData[][i]);

            measurementsData[][i] = (modulus + gslrangaussian(ffrng, sigmaMeasure*modulus))*exp(1i*(phase + gslrangaussian(ffrng, sigmaMeasure*2*pi)));

            modulus = abs(measurementsData[][i]);
            phase = arg(measurementsData[][i]);
        }
    }

    if(computeGradient)
    {
        //Create the verification mesh
        meshS verificationMesh = getSphericMesh(verificationSize,verificationResolution,0.0,elementTypeNameVerification);
        verificationMesh = OrientNormal(verificationMesh,unbounded=0);

        //Compute the analytical solution
        fespace UhOut(verificationMesh,PkVerification); //Verification data is computed on the mesh vertices !
        UhOut<complex> verificationData = inputFunction(frequency,studiedFunction);
        UhOut<complex> verificationDataGradient = inputFunctionGradient(frequency,studiedFunction);

        AcousticSL(frequency, measurementsMesh, measurementsData[], verificationMesh, verificationData[], outputFileName, verificationDataGradient[], outputFileNameGradient, "./", physicsFactor);
        AcousticCL(frequency, measurementsMesh, measurementsData[], verificationMesh, verificationData[], outputFileName, verificationDataGradient[], outputFileNameGradient, "./", physicsFactor);
    }
    else
    {
       //Create the verification mesh
        meshL verificationMesh = getCircularMesh(verificationSize,verificationResolution,0.0,elementTypeNameVerification);
        verificationMesh = OrientNormal(verificationMesh,unbounded=0);

        //Compute the analytical solution
        fespace UhOut(verificationMesh,PkVerification); //Verification data is computed on the mesh vertices !
        UhOut<complex> verificationData = inputFunction(frequency,studiedFunction);

        AcousticSL(frequency, measurementsMesh, measurementsData[], verificationMesh, verificationData[], outputFileName, "./", physicsFactor);
        AcousticCL(frequency, measurementsMesh, measurementsData[], verificationMesh, verificationData[], outputFileName, "./", physicsFactor); 
    }
}