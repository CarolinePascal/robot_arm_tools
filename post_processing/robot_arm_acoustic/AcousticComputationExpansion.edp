load "gsl"
load "shell"
load "iovtk"
load "medit"
load "msh3"

load "gsl"
gslrng ffrng;

include "ComputationTools.edp"
include "AcousticTools.edp"
include "MeasurementsTools.edp"
include "FactorizationTools.edp"

include "getARGV.idp"

verbosity = 0;

//Real measurements flag macro must be defined here for compilation purposes 

IFMACRO(realMeasurements,0)
func real k(real frequency){return kref(frequency);}
ENDIFMACRO
IFMACRO(realMeasurements,1)
func real k(real frequency){return kmeas(frequency);}
ENDIFMACRO
IFMACRO(!realMeasurements)
func real k(real frequency){return kref(frequency);}
macro realMeasurements 0 //
ENDIFMACRO

//Whole range associated legendre polynomials with spherical harmonics normalization
func complex Plm(int l, int m, real x)
{
    if(m >= 0)
    {
        return(gslsflegendresphPlm(l,m,x));
    }
    else
    {
        return(pow(-1,-m)*gslsflegendresphPlm(l,-m,x));
    }  
}

//Spherical hankel function of the first kind
func complex sphericalHankelFirstKind(int l, real x)
{
    return(gslsfbesseljl(l,x) + 1i*gslsfbesselyl(l,x));
}

//Spherical hankel function of the second kind
func complex sphericalHankelSecondKind(int l, real x)
{
    return(gslsfbesseljl(l,x) - 1i*gslsfbesselyl(l,x));
}

//Spherical harmonics
func complex Ylm(int l, int m, real theta, real phi)
{
    return(Plm(l,m,cos(theta))*exp(1i*m*phi));
}

//General spherical Helmholtz equation solution 
func complex sphericalHelmholtzSolution(complex[int] Alm, int size, real frequency)
{
    int lMax = sqrt(size) - 1;
    complex output = 0;
    for(int l = 0; l <= lMax; l++)
    {
        for(int m = -l; m <= l; m++)
        {
            output += Alm[l*l + m + l]*Ylm(l,m,theta,phi)*sphericalHankelFirstKind(l,k(frequency)*r);
        }
    }
    return(output);
}

//Element type macro must be defined here for compilation purposes 

IFMACRO(!elementType)
func Pk = P0;
string elementTypeName = "P0";
ENDIFMACRO
IFMACRO(elementType)
func Pk = elementType;
string elementTypeName = Stringification(elementType);
ENDIFMACRO

func int AcousticSFT(real frequency, int expansionNumber, meshS &measurementsMesh, complex[int] measurementsData, meshL &verificationMesh, complex[int] verificationData, string outputFileName, string outputFolder)
{
    //Retrieve measurements
    fespace Uh(measurementsMesh,Pk);
    Uh<complex> measurements;
    measurements[] = measurementsData;

    //Compute general solution coefficients

    //SFT
    int lMax = sqrt(expansionNumber) - 1;
    complex[int] Alm((lMax+1)*(lMax+1)); 
    for(int l = 0; l <= lMax; l++)
    {
        for(int m = -l; m <= l; m++)
        {
            Alm[l*l + m + l] = int2d(measurementsMesh)(measurements*conj(Ylm(l,m,theta,phi))/(r*r*sphericalHankelFirstKind(l,k(frequency)*r)));
        }
    }

    //Evaluate the solution on the verification points
    fespace UhOut(verificationMesh,P1);

    //Compute the numerical solution
    UhOut<complex> uN = sphericalHelmholtzSolution(Alm,Alm.n,frequency);
    
    //Compute the analytical solution
    UhOut<complex> uA;
    uA[] = verificationData;

    //DEBUG
    if(mpirank == 0)
    {
        real l2Error = sqrt(int1d(verificationMesh)(abs(uA-uN)^2))/sqrt(int1d(verificationMesh)(abs(uA)^2));
        cout << "L2 ERROR SFT (RELATIVE) : " << l2Error << endl;
        UhOut delta = abs(uA-uN);
        UhOut reference = abs(uA);
        cout << "LINF ERROR SFT (RELATIVE) : " << delta[].max/reference[].max << endl;
    }

    //Fill output file
    string outputFilePath = outputFolder + "SFT/" + outputFileName;
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < verificationMesh.nv; i++)
    {
        file << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

func int AcousticESM(real frequency, int expansionNumber, meshS &measurementsMesh, complex[int] &measurementsData, meshL &verificationMesh, complex[int] verificationData, string outputFileName, string outputFolder)
{
    //Retrieve measurements points
    fespace Uh(measurementsMesh,Pk);

    //Compute general solution coefficients

    //ESM
    int lMax = sqrt(expansionNumber) - 1;
    matrix<complex> H(measurementsData.n,(lMax+1)*(lMax+1));
    for(int l = 0; l <= lMax; l++)
    {
        for(int m = -l; m <= l; m++)
        {
            Uh<complex> localExpansion = Ylm(l,m,theta,phi)*sphericalHankelFirstKind(l,k(frequency)*r);
            for(int i = 0; i < measurementsData.n; i++)
            {
                H(i,l*l + m + l) = localExpansion[][i];
            }
        }
    }

    if(mpirank == 0)
    {
        cout << "Measurements number : " << measurementsData.n << endl;
        cout << "Expansion number : " << (lMax+1)*(lMax+1) << endl;
        cout << "H : " << H.n << " x " << H.m << endl;
    }
    complex[int] Alm = regularizedFactorization(H, measurementsData, 0.0001, true);

    //Evaluate the solution on the verification points
    fespace UhOut(verificationMesh,P1);

    //Compute the numerical solution
    UhOut<complex> uN = sphericalHelmholtzSolution(Alm,Alm.n,frequency);
    
    //Compute the analytical solution
    UhOut<complex> uA;
    uA[] = verificationData;

    //DEBUG
    if(mpirank == 0)
    {
        real l2Error = sqrt(int1d(verificationMesh)(abs(uA-uN)^2))/sqrt(int1d(verificationMesh)(abs(uA)^2));
        cout << "L2 ERROR ESM (RELATIVE) : " << l2Error << endl;
        UhOut delta = abs(uA-uN);
        UhOut reference = abs(uA);
        cout << "LINF ERROR ESM (RELATIVE) : " << delta[].max/reference[].max << endl;
    }

    //Fill output file
    string outputFilePath = outputFolder + "ESM/" + outputFileName;
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < verificationMesh.nv; i++)
    {
        file << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

//MAIN

//Global parameters
real frequency = getARGV("-frequency",100); 
int expansionNumber = getARGV("-expansionNumber",0);
string method = getARGV("-method","SFT");

string fileID = getARGV("-fileID","");
if(fileID != "")
{
    fileID = "_" + fileID;
}

//TODO Gradient

//Real measurements
if(realMeasurements == 1)
{
    //Real measurements parameters
    string measurementsMeshPath = getARGV("-measurementsMeshPath","");
    string measurementsDataPath = getARGV("-measurementsDataPath",""); 
    string verificationMeshPath = getARGV("-verificationMeshPath","");
    string verificationDataPath = getARGV("-verificationDataPath",""); 

    string outputFolder = dirname(measurementsDataPath) + "/";
    if(isdir(outputFolder + method) == -1)
    {
        mkdir(outputFolder + method);
    }
    string outputFileName = elementTypeName + "/output_" + frequency + fileID + ".csv";

    meshS measurementsMesh(measurementsMeshPath);
    measurementsMesh = OrientNormal(measurementsMesh,unbounded=1);
    complex[int] measurementsData = getData(measurementsDataPath);

    meshL verificationMesh(verificationMeshPath);
    verificationMesh = OrientNormal(verificationMesh,unbounded=0);
    complex[int] verificationData = getData(verificationDataPath);  

    if(expansionNumber == 0)
    {
        expansionNumber = measurementsData.n;
    }

    if(method == "ESM")
    {
        AcousticESM(frequency, expansionNumber, measurementsMesh, measurementsData, verificationMesh, verificationData, outputFileName, outputFolder);
    }
    else if(method == "SFT")
    {
        AcousticSFT(frequency, expansionNumber, measurementsMesh, measurementsData, verificationMesh, verificationData, outputFileName, outputFolder);
    }
    else
    {
        cout << "Unknown method" << endl;
    }
}

//Simulation
else
{
    if(isdir("./" + method) == -1)
    {
        mkdir("./" + method);
    }

    //Simulation parameters
    real size = getARGV("-size",0.1); 
    real resolution = getARGV("-resolution",0.015);
    real sigmaPosition = getARGV("-sigmaPosition",0.0);
    real sigmaMeasure = getARGV("-sigmaMeasure",0.0);

    real verificationSize = getARGV("-verificationSize",0.75);
    real verificationResolution = getARGV("-verificationResolution",0.05);

    string studiedFunction = getARGV("-studiedFunction", "monopole");
    real dipoleDistance = getARGV("-dipoleDistance",0.001);
    halfDipoleDistance = dipoleDistance/2;

    string outputFileName;
    string intermediateFolder = studiedFunction + "_" + elementTypeName + "/";

    if(studiedFunction == "dipole")
    {
        outputFileName = intermediateFolder + "output_" + frequency + "_" + resolution + "_" + size + "_" + dipoleDistance + "_" + sigmaPosition + "_" + sigmaMeasure + fileID + ".csv";
    }
    else
    {
        outputFileName = intermediateFolder + "output_" + frequency + "_" + resolution + "_" + size + "_" + sigmaPosition + "_" + sigmaMeasure + fileID + ".csv";
    }

    if(isdir("./" + method + "/" + studiedFunction + "_" + elementTypeName) == -1)
    {
        mkdir("./" + method + "/" + studiedFunction + "_" + elementTypeName);
    }

    //Retrieve simulation mesh (assumed perfect, as we can't precisely predict the robot pose error a posteriori)
    meshS measurementsMesh = getSphericMesh(size,resolution,0.0,elementTypeName);
    measurementsMesh = OrientNormal(measurementsMesh,unbounded=1);
    
    //Create simulated measurements
    fespace Uh(measurementsMesh,Pk);
    Uh<complex> measurementsData;
    
    //Noiseless position measurements
    if(sigmaPosition == 0)
    {	
	    //Equivalent to Uh<complex> measurementsData = inputFunction(frequency,studiedFunction);
        Uh<complex> noisyMeasurementsData = inputFunction(frequency,studiedFunction);
        measurementsData[] = noisyMeasurementsData[];
    }    

    //Noisy position measurements
    else
    {
	    //Retrieve noisy simulation mesh (random position noise)
        meshS noisyMeasurementsMesh = getSphericMesh(size,resolution,sigmaPosition,elementTypeName);
        noisyMeasurementsMesh = OrientNormal(noisyMeasurementsMesh,unbounded=1);

        //Retrieve noisy simulated measurements
        fespace UhNoise(noisyMeasurementsMesh,Pk);
        UhNoise<complex> noisyMeasurementsData = inputFunction(frequency,studiedFunction);
        measurementsData[] = noisyMeasurementsData[];
    }

    /*if(mpirank == 0)
    {
        medit("Measurements",measurementsMesh,abs(measurementsData));
    }*/

    if(sigmaMeasure != 0.0)
    {
        real modulus, phase;
        for(int i = 0; i < measurementsData[].n; i++)
        {
            modulus = abs(measurementsData[][i]);
            phase = arg(measurementsData[][i]);

            measurementsData[][i] = (modulus + gslrangaussian(ffrng, sigmaMeasure*modulus))*exp(1i*(phase + gslrangaussian(ffrng, sigmaMeasure*2*pi)));

            modulus = abs(measurementsData[][i]);
            phase = arg(measurementsData[][i]);
        }
    }

    //Create the verification mesh
    meshL verificationMesh = getCircularMesh(verificationSize,verificationResolution,0.0,"P1");
    verificationMesh = OrientNormal(verificationMesh,unbounded=0);

    //Compute the analytical solution
    fespace UhOut(verificationMesh,P1); //Verification data is computed on the mesh vertices !
    UhOut<complex> verificationData = inputFunction(frequency,studiedFunction);

    if(expansionNumber == 0)
    {
        expansionNumber = measurementsData[].n;
    }

    if(method == "ESM")
    {
        AcousticESM(frequency, expansionNumber, measurementsMesh, measurementsData[], verificationMesh, verificationData[], outputFileName,"./");
    }
    else if(method == "SFT")
    {
        AcousticSFT(frequency, expansionNumber, measurementsMesh, measurementsData[], verificationMesh, verificationData[], outputFileName,"./");
    }
    else
    {
        cout << "Unknown method" << endl;
    }
}


