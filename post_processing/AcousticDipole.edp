load "msh3"
load "medit"
load "shell"

include "Sphere.edp"

//Sound parameters
real Pref = 20e-6; //Pa
real rho = 1.204;   //kg/m³ at 20°C
real c = 343.4;   //m/s at 20°C

//Sound source
real Q = 1; //m³/s
real d = 0.05;  //m

//Integration spheres parameters 
real Rmin = 0.10;   //m
real Rmax = 1.00;   //m
real R = 2.0;   //m
int minVerticesNumber = 100;    //Per sphere !

//Spherical coordinates functions
func r = sqrt(x*x + y*y + z*z);
func theta = atan2(sqrt(x*x + y*y),z);
func phi = atan2(y,x); 

func real[int] logspace(real minPow, real maxPow, int itemNumber)
{
    real delta = (maxPow - minPow)/(itemNumber-1);
    real[int] output(itemNumber);

    for (int i = 0; i < itemNumber; i++)
    {
        output[i] = pow(10,minPow+i*delta);
    }

    return(output);
}

func mesh halfThinSphere(real Rint, real Rext, int angularVerticesNumber, int interiorLabel, int exteriorLabel)
{
    border exteriorCircle(t = pi/2,pi/2 + 2*pi){x = Rext*cos(t); y = Rext*sin(t); label = exteriorLabel;}
    border interiorCircle(t = pi/2,pi/2 + 2*pi){x = Rint*cos(t); y = Rint*sin(t); label = interiorLabel;}
    
    mesh Th2d = buildmesh(exteriorCircle(angularVerticesNumber) + interiorCircle(-angularVerticesNumber), fixedborder=true);
    
    //DEBUG
    //plot(Th2d,wait=true);

    Th2d = trunc(Th2d, x>0);

    //DEBUG
    //plot(Th2d,wait=true);

    return(Th2d);
}

func mesh3 thickSphere(real Rmin, real Rmax, int angularVerticesNumber, int radialVerticesNumber)
{
        real delta = (Rmax-Rmin)/(radialVerticesNumber-1);
        int currentLabel = 1;
        mesh Th2d;

        for(real radius = Rmin; radius < Rmax; radius += delta)
        {
            Th2d = Th2d + halfThinSphere(radius,radius+delta,angularVerticesNumber,currentLabel,currentLabel+1);
            currentLabel += 1;
        }

        //DEBUG
        //plot(Th2d,wait=true);

        //Building the 3D thick sphere
        func fx = x*cos(z);
        func fy = x*sin(z);
        func fz = y;        

        mesh3 Th3d = buildlayers(Th2d, angularVerticesNumber, zbound=[0, 2*pi], transfo=[fx, fy, fz]);

        //DEBUG
        //medit("3d thick sphere mesh", Th3d);

        //fespace debug(Th3d,P1);
        //debug labels = label;

        //medit("Labels",Th3d,labels);

        return(Th3d);
}

func int getAngularVerticesNumber(int sphereVerticesNumber, int radialVerticesNumber)
{
    real result = 1 + sqrt(1 + sphereVerticesNumber*radialVerticesNumber - 2*radialVerticesNumber);
    int output = floor(result);

    if(output%2 == 0)
    {
        return(output);
    }
    else
    {
        return(output+1);
    }
}

func int acousticDipole(real frequency, real dipoleDistance, real Rmin, real Rmax, real R, int minVerticesNumber, int iterations)
{ 
    mkdir("+outputs_"+frequency+"_"+dipoleDistance);

    //Frequency parameters
    real k = 2*pi*frequency/c;
    real omega = c*k;

    //Acoustic dipole parameters
    real demid = dipoleDistance/2;

    //Acoustic field functions
    func G = exp(-1i*k*r)/(4*pi*r);
    func Pfar = (1i*omega*rho*Q) * G * 1i*2*sin(k*demid*sin(theta)*cos(phi));

    func rplus = sqrt((x-demid)*(x-demid) + y*y + z*z);
    func rminus = sqrt((x+demid)*(x+demid) + y*y + z*z);
    func Gplus = exp(-1i*k*rplus)/(4*pi*rplus);
    func Gminus = exp(-1i*k*rminus)/(4*pi*rminus);

    func Pclose = (1i*omega*rho*Q) * (Gplus - Gminus);

    //Output data storage
    int[int] Vertices(iterations);
    real[int] Errors(iterations); 

    real[int] VerticesTargets = logspace(log10(minVerticesNumber),3+log10(minVerticesNumber),iterations);

    for (int j = 0; j < iterations; j++)
    {
        cout << "FREQUENCY : " + frequency + " (Hz) - DIPOLE DISTANCE : " + dipoleDistance + " (m)" << endl;
        cout << "ITERATION " + (j+1) + "/" + iterations << endl;
        //Mesh parameters
        int angularVerticesNumber = getAngularVerticesNumber(round(VerticesTargets[j]),2);

        //Building close field thick sphere
        mesh3 Th3d = thickSphere(Rmin, Rmax, angularVerticesNumber, 2);
        Vertices[j] = Th3d.nv;

        cout << "VERTICES TARGET : " + 2*round(VerticesTargets[j]) << endl;
        cout << "RADIAL VERTICES : " + 2 << endl;
        cout << "ANGULAR VERTICES TARGET : " + angularVerticesNumber << endl;
        cout << "VERTICES NUMBER : " + Th3d.nv << endl;

        //Building normal vectors
        fespace sphere(Th3d,P1);

        sphere normalx = sin(theta)*cos(phi);
        sphere normaly = sin(theta)*sin(phi);
        sphere normalz = cos(theta);

        //DEBUG
        //medit("Normal vectors",Th3d,[normalx,normaly,normalz]);

        //Creating the close acoustic pressure field
        sphere<complex> pressure = Pclose;

        //DEBUG
        //medit("Close acoustic pressure field",Th3d,abs(pressure));

        sphere<complex> dpressurex = dx(pressure);
        sphere<complex> dpressurey = dy(pressure);
        sphere<complex> dpressurez = dz(pressure);

        sphere<complex> dpressuren = dpressurex*normalx + dpressurey*normaly + dpressurez*normalz;

        //Building far field surfacic sphere
        meshS ThFar = meshSphere(R,R/5);
        fespace sphereFar(ThFar,P1);

        //Compute the K-H integral 
        sphereFar<complex> pressureSomme;

        for (int i = 0; i < ThFar.nv; i++)
        {
            real X = ThFar(i).x, Y = ThFar(i).y, Z = ThFar(i).z;

            func D = sqrt((x-X)*(x-X) + (y-Y)*(y-Y) + (z-Z)*(z-Z));

            func Gxyz = exp(-1i*k*D)/(4*pi*D);

            sphere<complex> green = Gxyz;
            sphere<complex> dgreenx = dx(green);
            sphere<complex> dgreeny = dy(green);
            sphere<complex> dgreenz = dz(green);

            sphere<complex> dgreenn = dgreenx*normalx + dgreeny*normaly + dgreenz*normalz;

            int[int] lab = [1];
            complex Psomme = int2d(Th3d,lab) (pressure*dgreenn-green*dpressuren);

            pressureSomme[][i] = Psomme;
        }

        //Compute the far acoustic pressure field
        sphereFar<complex> pressureAnalytic = Pfar;

        int cutSize = 500;
        real[int] X(cutSize);
        real[int] Y(cutSize);
        real[int] Z(cutSize);

        real[int] n = [0,0,1];

        planeCutPoints(R,n,cutSize,X,Y,Z);

        ofstream file("+outputs_"+frequency+"_"+dipoleDistance+"/data_output_"+Th3d.nv+".txt");
        for(int i = 0; i < cutSize; i++)
        {
            file << X[i] << ";" << Y[i] << ";" << Z[i] << ";" << real(pressureSomme(X[i],Y[i],Z[i])) << ";" << imag(pressureSomme(X[i],Y[i],Z[i])) << ";" << real(pressureAnalytic(X[i],Y[i],Z[i])) << ";" << imag(pressureAnalytic(X[i],Y[i],Z[i])) << endl;
        }

        //DEBUG
        //medit("Acousitc pressure field - Analytic solution",ThFar,20*log10(max(Pref,abs(pressureAnalytic))/Pref));
        //medit("Acoustic pressure field - KH solution",ThFar,20*log10(max(Pref,abs(pressureSomme))/Pref));

        sphereFar<complex> delta = 20*log10(max(Pref,abs(pressureSomme))/Pref) - 20*log10(max(Pref,abs(pressureAnalytic))/Pref);
        real error = int2d(ThFar) (abs(delta));
        
        Errors[j] = error/(4*pi*R*R);

        //DEBUG
        //cout << "Global error : " << error/(4*pi*R*R) << endl;
        //medit("Error",ThFar,abs(delta));
    }

    {
        ofstream file("+outputs_"+frequency+"_"+dipoleDistance+"/error_output.txt");
        for (int i = 0; i < iterations; i++)
        {
            file << Vertices[i] << ";" << Errors[i] << endl;
        }
    }

    return(0);
}

//MAIN

//int frequenciesNumber = 10;
int frequenciesNumber = 1;
//int iterationsNumber = 50;
int iterationsNumber = 10;

//real[int] F = logspace(log10(20),log10(20000),frequenciesNumber);
real[int] F = [20];

for (int i = 0; i < frequenciesNumber; i++)
{
    acousticDipole(F[i],d,Rmin,Rmax,R,minVerticesNumber,iterationsNumber);
}

