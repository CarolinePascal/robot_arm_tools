load "msh3"
load "medit"
load "shell"

include "ComputationTools.edp"
include "SphericMeshTools.edp"
include "getARGV.idp"

verbosity = 0;

func int acousticDipole(real frequency, real dipoleDistance, real Rmin, real Rmax, real R, int angularVerticesNumber)
{ 
    //Frequency parameters
    real k = 2*pi*frequency/c;
    real omega = c*k;

    //Acoustic dipole parameters
    real demid = dipoleDistance/2;

    //Acoustic field functions
    func G = exp(-1i*k*r)/(4*pi*r);
    //func Pfar = (1i*omega*rho*Q) * G * 1i*2*sin(k*demid*sin(theta)*cos(phi));

    func rplus = sqrt((x-demid)*(x-demid) + y*y + z*z);
    func rminus = sqrt((x+demid)*(x+demid) + y*y + z*z);
    func Gplus = exp(-1i*k*rplus)/(4*pi*rplus);
    func Gminus = exp(-1i*k*rminus)/(4*pi*rminus);

    func Pressure = (1i*omega*rho*Q) * (Gplus - Gminus);

    //DEBUG
    //cout << "TOTAL VERTICES NUMBER : " + 2*angularVerticesNumber*(angularVerticesNumber-1) << endl;
    //cout << "FREQUENCY : " + frequency + " (Hz) - DIPOLE DISTANCE : " + dipoleDistance + " (m)" << endl;
    //cout << "INSIDE RADIUS : " + Rmin + " (m) - OUTSIDE RADIUS : " + Rmax +" (m) - FAR FIELD RADIUS : " + R + " (m)" << endl;

    //Loading close thick sphere mesh
    string meshName = "meshes/thick_sphere/TS_" + angularVerticesNumber + "_" + Rmin + "_" + Rmax + ".mesh";
    mesh3 ThClose(meshName);
    fespace closeSphere(ThClose,P1);

    //Building normal vectors
    closeSphere nx = normalx;
    closeSphere ny = normaly;
    closeSphere nz = normalz;

    //DEBUG
    //medit("Normal vectors on the close thick sphere",THClose,[nx,ny,nz]);

    //Creating the acoustic pressure field
    closeSphere<complex> pressure = Pressure;

    //DEBUG
    //medit("Acoustic pressure field on the close thick sphere",THClose,abs(pressure));

    closeSphere<complex> dpressurex = dx(pressure);
    closeSphere<complex> dpressurey = dy(pressure);
    closeSphere<complex> dpressurez = dz(pressure);

    closeSphere<complex> dpressuren = dpressurex*nx + dpressurey*ny + dpressurez*nz;

    //Building far surfacic sphere mesh
    meshS ThFar = meshSphere(R,R/5);
    fespace farSphere(ThFar,P1);

    //Compute the K-H integral 
    farSphere<complex> pressureIntegral;

    for (int i = 0; i < ThFar.nv; i++)
    {
        real X = ThFar(i).x, Y = ThFar(i).y, Z = ThFar(i).z;

        func D = sqrt((x-X)*(x-X) + (y-Y)*(y-Y) + (z-Z)*(z-Z));

        func Gxyz = exp(-1i*k*D)/(4*pi*D);

        closeSphere<complex> green = Gxyz;
        closeSphere<complex> dgreenx = dx(green);
        closeSphere<complex> dgreeny = dy(green);
        closeSphere<complex> dgreenz = dz(green);

        closeSphere<complex> dgreenn = dgreenx*nx + dgreeny*ny + dgreenz*nz;

        int[int] lab = [1];
        pressureIntegral[][i] = int2d(ThClose,lab) (pressure*dgreenn-green*dpressuren);
    }
    
    //Creating the acoustic pressure field
    farSphere<complex> pressureAnalytic = Pressure;

    int cutSize = 500;
    real[int] X(cutSize);
    real[int] Y(cutSize);
    real[int] Z(cutSize);

    real[int] n = [0,0,1];

    planeCutPoints(R,n,cutSize,X,Y,Z);

    string folderName = getARGV("-folderName","Baseline");

    ofstream parameters(folderName+"/parameters.txt");
    parameters << "vertices\n";
    parameters << "frequency\n";
    parameters << "dipoleDistance\n";
    parameters << "Rmin\n";
    parameters << "Rmax\n";
    parameters << "R\n";

    ofstream file(folderName+"/output_"+angularVerticesNumber+"_"+frequency+"_"+dipoleDistance+"_"+Rmin+"_"+Rmax+"_"+R+".txt");
    for(int i = 0; i < cutSize; i++)
    {
        file << X[i] << ";" << Y[i] << ";" << Z[i] << ";" << real(pressureIntegral(X[i],Y[i],Z[i])) << ";" << imag(pressureIntegral(X[i],Y[i],Z[i])) << ";" << real(pressureAnalytic(X[i],Y[i],Z[i])) << ";" << imag(pressureAnalytic(X[i],Y[i],Z[i])) << endl;
    }

    //DEBUG
    //medit("Acousitc pressure field - Analytic solution",ThFar,20*log10(max(Pref,abs(pressureAnalytic))/Pref));
    //medit("Acoustic pressure field - KH solution",ThFar,20*log10(max(Pref,abs(pressureIntegral))/Pref));

    farSphere<complex> delta = 20*log10(max(Pref,abs(pressureIntegral))/Pref) - 20*log10(max(Pref,abs(pressureAnalytic))/Pref);
    real error = int2d(ThFar) (abs(delta));
    cout << error/(4*pi*R*R) << endl;

    //DEBUG
    //medit("Error",ThFar,abs(delta));

    return(0);
}

//MAIN
real frequency = getARGV("-frequency",2000); 
real dipoleDistance = getARGV("-dipoleDistance",0.05); 
real Rmin = getARGV("-Rmin",0.2); 
real Rmax = getARGV("-Rmax",0.21); 
real R = getARGV("-R",0.4); 
int angularVerticesNumber = getARGV("-angularVerticesNumber",10); 

acousticDipole(frequency,dipoleDistance,Rmin,Rmax,R,angularVerticesNumber);


