load "msh3"
load "medit"
load "shell"

include "ComputationTools.edp"
include "SphericMeshTools.edp"
include "getARGV.idp"

verbosity = 0;

func int acousticDipole(real frequency, real dipoleDistance, real Rmin, real Rmax, real R, int angularVerticesNumber)
{ 
    //Frequency parameters
    real k = 2*pi*frequency/c;
    real omega = c*k;

    //Acoustic dipole parameters
    real demid = dipoleDistance/2;

    //Acoustic field functions
    func G = exp(-1i*k*r)/(4*pi*r);
    //func PressureFar = (1i*omega*rho*Q) * G * 1i*2*sin(k*demid*sin(theta)*cos(phi));

    func rplus = sqrt((x-demid)*(x-demid) + y*y + z*z);
    func rminus = sqrt((x+demid)*(x+demid) + y*y + z*z);
    func Gplus = exp(-1i*k*rplus)/(4*pi*rplus);
    func Gminus = exp(-1i*k*rminus)/(4*pi*rminus);

    func Pressure = (1i*omega*rho*Q) * (Gplus - Gminus);

    //Acoustic field normal derivative functions
    func dGplusr = -Gplus*(1i*k*rplus + 1)/rplus;
    func dGminusr = -Gminus*(1i*k*rminus + 1)/rminus;

    func dPx = (1i*omega*rho*Q) * (dGplusr*(x-demid)/rplus - dGminusr*(x+demid)/rminus);
    func dPy = (1i*omega*rho*Q) * (dGplusr*y/rplus - dGminusr*y/rminus);
    func dPz = (1i*omega*rho*Q) * (dGplusr*z/rplus - dGminusr*z/rminus);

    func dpressuren = dPx*normalx + dPy*normaly + dPz*normalz;

    //Loading close thick sphere mesh
    string meshName = "meshes/thick_sphere/TS_" + angularVerticesNumber + "_" + Rmin + "_" + Rmax + ".mesh";
    mesh3 ThClose(meshName);
    fespace closeSphere(ThClose,P1);

    //Creating the acoustic pressure field
    closeSphere<complex> pressure = Pressure;

    //DEBUG
    //medit("Acoustic pressure field on the close thick sphere",THClose,abs(pressure));

    //Computing the normal derivative of the acoustic pressure field
    closeSphere<complex> dpressurenN = dx(pressure)*normalx + dy(pressure)*normaly + dz(pressure)*normalz;
    closeSphere<complex> dpressurenA = dpressuren;

    //Create cut points
    int cutSize = 500;
    real[int] X(cutSize);
    real[int] Y(cutSize);
    real[int] Z(cutSize);

    real[int] n = [0,0,1];

    planeCutPoints(R,n,cutSize,X,Y,Z);

    //Get output folder and fill parameters
    string folderName = getARGV("-folderName","Integration");

    ofstream parameters(folderName+"/parameters.txt");
    parameters << "vertices\n";
    parameters << "frequency Hz\n";
    parameters << "dipoleDistance m\n";
    parameters << "Rmin m\n";
    parameters << "Rmax m\n";
    parameters << "R m\n";

     //Fill output file
    ofstream file(folderName+"/output_"+angularVerticesNumber+"_"+frequency+"_"+dipoleDistance+"_"+Rmin+"_"+Rmax+"_"+R+".txt");

    for(int i = 0; i < cutSize; i++)
    {
        //Compute the K-H integral 
        real X = X[i], Y = Y[i], Z = Z[i];

        func D = sqrt((x-X)*(x-X) + (y-Y)*(y-Y) + (z-Z)*(z-Z));
        func Gxyz = exp(-1i*k*D)/(4*pi*D);
        func dGxyzD = -Gxyz*(1i*k*D + 1)/D;
        func dGxyzx = dGxyzD*(x-X)/D;
        func dGxyzy = dGxyzD*(y-Y)/D;
        func dGxyzz = dGxyzD*(z-Z)/D;
        func dGxyzn = dGxyzx*normalx + dGxyzy*normaly + dGxyzz*normalz;

        int[int] lab = [1];
        complex pressureNumericValue = int2d(ThClose,lab) (Gxyz*dpressurenN - pressure*dGxyzn);
        complex pressureAnalyticValue = int2d(ThClose,lab) (Gxyz*dpressurenA - pressure*dGxyzn);

        file << X << ";" << Y << ";" << Z << ";" << real(pressureNumericValue) << ";" << imag(pressureNumericValue) << ";" << real(pressureAnalyticValue) << ";" << imag(pressureAnalyticValue) << endl;
    }

    return(0);
}

//MAIN
real frequency = getARGV("-frequency",2000.0); 
real dipoleDistance = getARGV("-dipoleDistance",0.05); 
real Rmin = getARGV("-Rmin",0.2); 
real Rmax = getARGV("-Rmax",0.21); 
real R = getARGV("-R",0.4); 
int angularVerticesNumber = getARGV("-angularVerticesNumber",10); 

acousticDipole(frequency,dipoleDistance,Rmin,Rmax,R,angularVerticesNumber);


