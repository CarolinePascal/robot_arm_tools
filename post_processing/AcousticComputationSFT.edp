load "gsl"
load "shell"
load "iovtk"
load "medit"
load "msh3"

include "computationTools.edp"
include "acousticTools.edp"
include "measurementsTools.edp"

include "getARGV.idp"

verbosity = 0;

//Whole range associated legendre polynomials with spherical harmonics normalization
func complex Plm(int l, int m, real x)
{
    if(m >= 0)
    {
        return(gslsflegendresphPlm(l,m,x));
    }
    else
    {
        return(pow(-1,-m)*gslsflegendresphPlm(l,-m,x));
    }  
}

//Spherical harmonics
func complex Ylm(int l, int m, real theta, real phi)
{
    return(Plm(l,m,cos(theta))*exp(1i*m*phi));
}

//General spherical Helmholtz equation solution 
func complex sphericalHelmholtzSolution(complex[int] Alm, real frequency)
{
    int lMax = sqrt(Alm.n) - 1;
    complex output = 0;
    for(int l = 0; l <= lMax; l++)
    {
        for(int m = -l; m <= l; m++)
        {
            output += Alm[l*l + m + l]*Ylm(l,m,theta,phi)*gslsfbesseljl(l,k(frequency)*r);
        }
    }
    return(output);
}

//Element type macro must be defined here for compilation purposes 

IFMACRO(!elementType)
func Pk = P0;
string elementTypeName = "P0";
ENDIFMACRO
IFMACRO(elementType)
func Pk = elementType;
string elementTypeName = Stringification(elementType);
ENDIFMACRO

func int AcousticSFT(real frequency, meshS &measurementsMesh, complex[int] measurementsData, meshL &verificationMesh, complex[int] verificationData, string outputFileName)
{
    //Retrieve measurements
    fespace Uh(measurementsMesh,Pk);
    Uh<complex> measurements;
    measurements[] = measurementsData;

    //Compute general solution coefficients
    complex[int] Alm((LMAX+1)*(LMAX+1)); 
    for(int l = 0; l <= LMAX; l++)
    {
        for(int m = -l; m <= l; m++)
        {
            Alm[l*l + m + l] = int2d(ThS)(sin(theta)*measurements*conj(Ylm(l,m,theta,phi))/gslsfbesseljl(l,k(frequency)*r));
        }
    }

    //Evaluate the solution on the verification points
    fespace UhOut(verificationMesh,P1);

    //Compute the numerical solution
    UhOut<complex> uN = sphericalHelmholtzSolution(Alm,frequency);
    
    //Compute the analytical solution
    UhOut<complex> uA;
    uA[] = verificationData;

    //DEBUG
    real[int] error(uA.n);
    for(int i = 0; i < uA.n; i++)
    {
        error[i] = abs(uA[][i] - uN[][i]);
    }
    cout << "LINF ERROR SL : " << error.max << endl;

    //Fill output file
    string outputFilePath = "./SFT/" + outputFileName;
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < verificationMesh.nv; i++)
    {
        file << verificationMesh(i).x << ";" << verificationMesh(i).y << ";" << verificationMesh(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

//MAIN

//Global parameters
int realMeasurements = getARGV("-realMeasurements",0);
real frequency = getARGV("-frequency",100); 

string fileID = getARGV("-fileID","");
if(fileID != "")
{
    fileID = "_" + fileID;
}

if(isdir("./SFT") == -1)
{
    mkdir("./SFT");
}

//TODO Gradient

//Real measurements
if(realMeasurements == 1)
{
    string outputFileName = "output_" + frequency + fileID + ".csv";

    meshS measurementsMesh = getMeasurementsMesh();
    measurementsMesh = OrientNormal(measurementsMesh,unbounded=1);
    meshL verificationMesh = getVerificationMesh();
    verificationMesh = OrientNormal(verificationMesh,unbounded=0);

    complex[int] verificationData = getVerificationData(frequency);
    complex[int] measurementsData = getMeasurementsData(frequency);

    AcousticSFT(frequency, measurementsMesh, measurementsData, verificationMesh, verificationData, outputFileName);
}

//Simulation
else
{
    //Simulation parameters
    real size = getARGV("-size",0.1); 
    real resolution = getARGV("-resolution",0.05);
    real sigmaPosition = getARGV("-sigmaPosition",0.0);
    real sigmaMeasure = getARGV("-sigmaMeasure",0.0);

    real verificationSize = getARGV("-verificationSize",0.5);
    real verificationResolution = getARGV("-verificationResolution",0.1);

    string studiedFunction = getARGV("-studiedFunction", "monopole");
    real tmp = getARGV("-dipoleDistance",0.001);
    demid = tmp;

    string outputFileName = studiedFunction + "/output_" + frequency + "_" + resolution + "_" + size + "_" + sigmaPosition + "_" + sigmaMeasure + fileID + ".csv";

    if(isdir("./SFT/" + studiedFunction) == -1)
    {
        mkdir("./SFT/" + studiedFunction);
    }

    //Retrieve simulation mesh (assumed perfect, as we can't precisely predict the robot pose error a posteriori)
    meshS measurementsMesh = getSphericMesh(size,resolution,0.0,elementTypeName);
    measurementsMesh = OrientNormal(measurementsMesh,unbounded=1);
    
    //Create simulated measurements
    fespace Uh(measurementsMesh,Pk);
    Uh<complex> measurementsData;
    
    //Noiseless position measurements
    if(sigmaPosition == 0)
    {	
	    //Equivalent to Uh<complex> measurementsData = inputFunction(frequency,studiedFunction);
        Uh<complex> noisyMeasurementsData = inputFunction(frequency,studiedFunction);
        measurementsData[] = noisyMeasurementsData[];
    }    

    //Noisy position measurements
    else
    {
	    //Retrieve noisy simulation mesh (random position noise)
        meshS noisyMeasurementsMesh = getSphericMesh(size,resolution,sigmaPosition,elementTypeName);
        noisyMeasurementsMesh = OrientNormal(noisyMeasurementsMesh,unbounded=1);

        //Retrieve noisy simulated measurements
        fespace UhNoise(noisyMeasurementsMesh,Pk);
        UhNoise<complex> noisyMeasurementsData = inputFunction(frequency,studiedFunction);
        measurementsData[] = noisyMeasurementsData[];
    }

    /*if(mpirank == 0)
    {
        medit("Measurements",measurementsMesh,abs(measurementsData));
    }*/

    if(sigmaMeasure != 0.0)
    {
        for(int i = 0; i < measurementsData.n; i++)
        {
            measurementsData[][i] = real(measurementsData[][i]) + gslrangaussian(ffrng, sigmaMeasure) + 1i*(imag(measurementsData[][i]) + gslrangaussian(ffrng, sigmaMeasure));
        }
    }

    //Create the verification mesh
    meshL verificationMesh = getCircularMesh(verificationSize,verificationResolution,0.0,"P1");
    verificationMesh = OrientNormal(verificationMesh,unbounded=0);

    //Compute the analytical solution
    fespace UhOut(verificationMesh,P1); //Verification data is computed on the mesh vertices !
    UhOut<complex> verificationData = inputFunction(frequency,studiedFunction);

    AcousticSFT(frequency, measurementsMesh, measurementsData[], verificationMesh, verificationData[], outputFileName);
}


