load "gsl"
load "shell"
load "iovtk"
load "medit"
load "msh3"

include "computationTools.edp"
include "acousticTools.edp"
include "getARGV.idp"

int LMAX = 10;

verbosity = 0;

int cutSize = 100;

//Whole range associated legendre polynomials with spherical harmonics normalization
func complex Plm(int l, int m, real x)
{
    if(m >= 0)
    {
        return(gslsflegendresphPlm(l,m,x));
    }
    else
    {
        return(pow(-1,-m)*gslsflegendresphPlm(l,-m,x));
    }  
}

//Spherical harmonics
func complex Ylm(int l, int m, real theta, real phi)
{
    return(Plm(l,m,cos(theta))*exp(1i*m*phi));
}

//General spherical Helmholtz equation solution 
func complex sphericalHelmholtzSolution(complex[int] Alm, real frequency)
{
    complex output = 0;
    for(int l = 0; l <= LMAX; l++)
    {
        for(int m = -l; m <= l; m++)
        {
            output += Alm[l*l + m + l]*Ylm(l,m,theta,phi)*gslsfbesseljl(l,k(frequency)*r);
        }
    }
    return(output);
}

func meshS getSphericMesh(real size, real resolution)
{
    //Solve rounding issues...
    string sizeWithDecimal;
    if(size - floor(size) > 0)
    {
        sizeWithDecimal = size;
    }
    else
    {
        sizeWithDecimal = size + ".0";
    }

    string resolutionWithDecimal;
    if(resolution - floor(resolution) > 0)
    {
        resolutionWithDecimal = resolution;
    }
    else
    {
        resolutionWithDecimal = resolution + ".0";
    }

    //Load mesh
    meshS ThS("../config/meshes/sphere/" + sizeWithDecimal + "_" + resolutionWithDecimal + ".mesh");
    ThS = OrientNormal(ThS,unbounded=1);

    /*DEBUG
    fespace Dummy(ThS,P0);
    Dummy meshSize = hTriangle;
    cout << "MESH SIZE" << " expected : " << resolution << " real : " << meshSize[].max << endl;
    cout << "VERTICES NUMBER " << ThS.nv << endl;
    plot(ThS); 
    */   

    return(ThS);
}

func int AcousticSFT(real frequency, real size, real resolution, real cutRadius, string studiedFunction)
{
    //Load mesh
    meshS ThS = getSphericMesh(size,resolution);
    fespace Uh(ThS,P0);

    //Retrieve the "measurements"
    Uh<complex> measurements = inputFunction(frequency,studiedFunction);

    //Compute general solution coefficients
    complex[int] Alm((LMAX+1)*(LMAX+1)); 
    for(int l = 0; l <= LMAX; l++)
    {
        for(int m = -l; m <= l; m++)
        {
            Alm[l*l + m + l] = int2d(ThS)(sin(theta)*measurements*conj(Ylm(l,m,theta,phi))/gslsfbesseljl(l,k(frequency)*r));
        }
    }


    //Compute the numerical solution
    border circleN(t = 0, 2*pi){x=cutRadius*cos(t); y=cutRadius*sin(t);}
    meshL ThOutN = buildmeshL(circleN(cutSize));
    fespace UhOutN(ThOutN,P1);
    UhOutN<complex> uN = sphericalHelmholtzSolution(Alm,frequency);

    //Compute the analytical solution
    border circleA(t = 0, 2*pi){x=cutRadius*cos(t); y=cutRadius*sin(t);}
    meshL ThOutA = buildmeshL(circleA(cutSize));
    fespace UhOutA(ThOutA,P1);
    UhOutA<complex> uA = inputFunction(frequency,studiedFunction);

    /*DEBUG
    UhOut u = abs(uTh);
    cout << u[].max << endl;
    int[int] Order = [0];
    string DataName = "u";
    savevtk("out.vtu", ThOut, u, dataname=DataName, order=Order);
    */

    /*DEBUG*/
    real[int] error(uA.n);
    for(int i = 0; i < uA.n; i++)
    {
        error[i] = abs(uA[][i] - uN[][i]);
    }
    cout << "LINF ERROR SL : " << error.max << endl;

    //Fill output file
    string dirName = "SFT_" + studiedFunction + "_P0_SL";
    if(isdir("./" + dirName) == -1)
    {
        mkdir("./" + dirName);
    }
    string outputFilePath = "./" + dirName + "/output_" + frequency + "_" + resolution + "_" + size + ".txt";
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < cutSize; i++)
    {
        file << ThOutA(i).x << ";" << ThOutA(i).y << ";" << ThOutA(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

//MAIN

real frequency = getARGV("-frequency",100); 
real size = getARGV("-size",0.1); 
real resolution = getARGV("-resolution",0.05);
real cutRadius = getARGV("-cutRadius",0.5);

string studiedFunction = getARGV("-studiedFunction", "monopole");

real tmp = getARGV("-dipoleDistance",0.001);
demid = tmp;

AcousticSFT(frequency,size,resolution,cutRadius,studiedFunction);


