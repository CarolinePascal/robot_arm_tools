load "msh3"
load "medit"
load "shell"

include "ComputationTools.edp"
include "SphericMeshTools.edp"
include "getARGV.idp"

verbosity = 0;

func int derivativeComparaison(real frequency, real dipoleDistance, real R0, string elementType, string meshPath, string outputFilePath)
{
    //Frequency parameters
    real k = 2*pi*frequency/c;
    real omega = c*k;

    //Acoustic dipole parameters
    real demid = dipoleDistance/2;

    //Acoustic field functions
    func G = exp(-1i*k*r)/(4*pi*r);

    //Exact formulation
    func rplus = sqrt((x-demid)*(x-demid) + y*y + z*z);
    func rminus = sqrt((x+demid)*(x+demid) + y*y + z*z);
    func Gplus = exp(-1i*k*rplus)/(4*pi*rplus);
    func Gminus = exp(-1i*k*rminus)/(4*pi*rminus);

    func pressureA = (1i*omega*rho*Q) * (Gplus - Gminus);

    //Acoustic field normal derivative functions

    //Exact formulation
    func dGplusr = -Gplus*(1i*k*rplus + 1)/rplus;
    func dGminusr = -Gminus*(1i*k*rminus + 1)/rminus;
    func drplusr = (r - demid*sin(theta)*cos(phi))/rplus;
    func drminusr = (r + demid*sin(theta)*cos(phi))/rminus;
    func dpressurenA = (1i*omega*rho*Q) * (dGplusr*drplusr - dGminusr*drminusr);

    //Loading close thick sphere mesh
    mesh3 ThClose(meshPath);

    //Create cut points
    int cutSize = 500;
    real[int] X(cutSize);
    real[int] Y(cutSize);
    real[int] Z(cutSize);

    real[int] n = [0,0,1];

    planeCutPoints(R0,n,cutSize,X,Y,Z);

    //Get output folder and fill parameters
    string outputFolder = dirname(outputFilePath);

    ofstream parameters(outputFolder + "_/parameters.txt");
    parameters << "elementType\n";
    parameters << "layers\n";
    parameters << "vertices\n";
    parameters << "frequency Hz\n";
    parameters << "dipoleDistance m\n";
    parameters << "R0 m\n";
    parameters << "deltaR m\n";

    //Fill output file
    ofstream file(outputFilePath);

    if(elementType == "P1")
    {
        fespace closeSphere(ThClose,P1);

        //Creating the acoustic pressure field
        closeSphere<complex> pressureN = pressureA;

        //Computing the normal derivative of the acoustic pressure field
        closeSphere<complex> dpressurenN = dx(pressureN)*normalx + dy(pressureN)*normaly + dz(pressureN)*normalz;

        for(int i = 0; i < cutSize; i++)
        {
            real X = X[i], Y = Y[i], Z = Z[i];
            file << X << ";" << Y << ";" << Z << ";" << real(dpressurenN(X,Y,Z)) << ";" << imag(dpressurenN(X,Y,Z)) << ";" << real(dpressurenA(X,Y,Z)) << ";" << imag(dpressurenA(X,Y,Z)) << endl;
        }
    }

    else if (elementType == "P2")
    {
        fespace closeSphere(ThClose,P2);

        //Creating the acoustic pressure field
        closeSphere<complex> pressureN = pressureA;

        //Computing the normal derivative of the acoustic pressure field
        closeSphere<complex> dpressurenN = dx(pressureN)*normalx + dy(pressureN)*normaly + dz(pressureN)*normalz;
        
        for(int i = 0; i < cutSize; i++)
        {
            real X = X[i], Y = Y[i], Z = Z[i];
            file << X << ";" << Y << ";" << Z << ";" << real(dpressurenN(X,Y,Z)) << ";" << imag(dpressurenN(X,Y,Z)) << ";" << real(dpressurenA(X,Y,Z)) << ";" << imag(dpressurenA(X,Y,Z)) << endl;
        }
    }

    return(0);
}

func int infinitesimalDerivativeComparaison(real frequency, real R0, string elementType, string meshPath, string outputFilePath)
{
    //Frequency parameters
    real k = 2*pi*frequency/c;
    real omega = c*k;

    //Acoustic field functions
    func G = exp(-1i*k*r)/(4*pi*r);

    //Infinitesimal formulation
    func pressureA = (-dipoleMomentum*rho*c*k*k)*sin(theta)*cos(phi)*G*(1 + 1/(1i*k*r));

    //Acoustic field normal derivative functions

    //Infinitesimal formulation
    func dpressurenA = (1i*dipoleMomentum*rho*c*k)*sin(theta)*cos(phi)*(G/(r*r))*((k*r - 1i)*(k*r - 1i) - 1);

    //Loading close thick sphere mesh
    mesh3 ThClose(meshPath);

    //Create cut points
    int cutSize = 500;
    real[int] X(cutSize);
    real[int] Y(cutSize);
    real[int] Z(cutSize);

    real[int] n = [0,0,1];

    planeCutPoints(R0,n,cutSize,X,Y,Z);

    //Get output folder and fill parameters
    string outputFolder = dirname(outputFilePath);

    ofstream parameters(outputFolder + "_/parameters.txt");
    parameters << "elementType\n";
    parameters << "layers\n";
    parameters << "vertices\n";
    parameters << "frequency Hz\n";
    parameters << "dipoleDistance m\n";
    parameters << "R0 m\n";
    parameters << "deltaR m\n";

    //Fill output file
    ofstream file(outputFilePath);

    if(elementType == "P1")
    {
        fespace closeSphere(ThClose,P1);

        //Creating the acoustic pressure field
        closeSphere<complex> pressureN = pressureA;

        //Computing the normal derivative of the acoustic pressure field
        closeSphere<complex> dpressurenN = dx(pressureN)*normalx + dy(pressureN)*normaly + dz(pressureN)*normalz;

        for(int i = 0; i < cutSize; i++)
        {
            real X = X[i], Y = Y[i], Z = Z[i];
            file << X << ";" << Y << ";" << Z << ";" << real(dpressurenN(X,Y,Z)) << ";" << imag(dpressurenN(X,Y,Z)) << ";" << real(dpressurenA(X,Y,Z)) << ";" << imag(dpressurenA(X,Y,Z)) << endl;
        }
    }

    else if (elementType == "P2")
    {
        fespace closeSphere(ThClose,P2);

        //Creating the acoustic pressure field
        closeSphere<complex> pressureN = pressureA;

        //Computing the normal derivative of the acoustic pressure field
        closeSphere<complex> dpressurenN = dx(pressureN)*normalx + dy(pressureN)*normaly + dz(pressureN)*normalz;
        
        for(int i = 0; i < cutSize; i++)
        {
            real X = X[i], Y = Y[i], Z = Z[i];
            file << X << ";" << Y << ";" << Z << ";" << real(dpressurenN(X,Y,Z)) << ";" << imag(dpressurenN(X,Y,Z)) << ";" << real(dpressurenA(X,Y,Z)) << ";" << imag(dpressurenA(X,Y,Z)) << endl;
        }
    }

    return(0);
}

//MAIN
real frequency = getARGV("-frequency",200.0); 
real dipoleDistance = getARGV("-dipoleDistance",0.05); 
real R0 = getARGV("-R0",0.2); 

string elementType = getARGV("-element","P1");
string meshPath = getARGV("-mesh","");
string outputFilePath = getARGV("-output","");

if(dipoleDistance == 0)
{
    infinitesimalDerivativeComparaison(frequency,R0,elementType,meshPath,outputFilePath);
}
else
{
    derivativeComparaison(frequency,dipoleDistance,R0,elementType,meshPath,outputFilePath);
}

