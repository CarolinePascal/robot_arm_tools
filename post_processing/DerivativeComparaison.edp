load "msh3"
load "medit"
load "shell"

include "ComputationTools.edp"
include "SphericMeshTools.edp"
include "getARGV.idp"

verbosity = 0;

func int derivativeComparaison(real frequency, real dipoleDistance, real Rmin, real Rmax, int angularVerticesNumber)
{
    //Frequency parameters
    real k = 2*pi*frequency/c;
    real omega = c*k;

    //Acoustic dipole parameters
    real demid = dipoleDistance/2;

    //Acoustic field functions
    func G = exp(-1i*k*r)/(4*pi*r);

    func rplus = sqrt((x-demid)*(x-demid) + y*y + z*z);
    func rminus = sqrt((x+demid)*(x+demid) + y*y + z*z);
    func Gplus = exp(-1i*k*rplus)/(4*pi*rplus);
    func Gminus = exp(-1i*k*rminus)/(4*pi*rminus);

    func pressureA = (1i*omega*rho*Q) * (Gplus - Gminus);

    //Acoustic field normal derivative functions
    func dGplusr = -Gplus*(1i*k*rplus + 1)/rplus;
    func dGminusr = -Gminus*(1i*k*rminus + 1)/rminus;

    func dPx = (1i*omega*rho*Q) * (dGplusr*(x-demid)/rplus - dGminusr*(x+demid)/rminus);
    func dPy = (1i*omega*rho*Q) * (dGplusr*y/rplus - dGminusr*y/rminus);
    func dPz = (1i*omega*rho*Q) * (dGplusr*z/rplus - dGminusr*z/rminus);

    func dpressurenA = dPx*normalx + dPy*normaly + dPz*normalz;

    string meshName = "meshes/thick_sphere/TS_" + angularVerticesNumber + "_" + Rmin + "_" + Rmax + ".mesh";
    mesh3 ThClose(meshName);
    fespace closeSphere(ThClose,P2);

    //Creating the acoustic pressure field
    closeSphere<complex> pressureN = pressureA;

    //DEBUG
    //medit("Analytical pressure field on the close thick sphere",THClose,abs(pressure));

    //Computing the normal derivative of the acoustic pressure field
    closeSphere<complex> dpressurenN = dx(pressureN)*normalx + dy(pressureN)*normaly + dz(pressureN)*normalz;    

    //Create cut points
    int cutSize = 500;
    real[int] X(cutSize);
    real[int] Y(cutSize);
    real[int] Z(cutSize);

    real[int] n = [0,0,1];

    planeCutPoints(Rmin,n,cutSize,X,Y,Z);

    //Get output folder and fill parameters
    string folderName = getARGV("-folderName","Derivative");

    ofstream parameters(folderName+"/parameters.txt");
    parameters << "vertices\n";
    parameters << "frequency Hz\n";
    parameters << "dipoleDistance m\n";
    parameters << "Rmin m\n";
    parameters << "Rmax m\n";

    //Fill output file
    ofstream file(folderName+"/output_"+angularVerticesNumber+"_"+frequency+"_"+dipoleDistance+"_"+Rmin+"_"+Rmax+".txt");

    for(int i = 0; i < cutSize; i++)
    {
        real X = X[i], Y = Y[i], Z = Z[i];
        file << X << ";" << Y << ";" << Z << ";" << real(dpressurenN(X,Y,Z)) << ";" << imag(dpressurenN(X,Y,Z)) << ";" << real(dpressurenA(X,Y,Z)) << ";" << imag(dpressurenA(X,Y,Z)) << endl;
    }

    return(0);
}

//MAIN
real frequency = getARGV("-frequency",200.0); 
real dipoleDistance = getARGV("-dipoleDistance",0.05); 
real Rmin = getARGV("-Rmin",0.2); 
real Rmax = getARGV("-Rmax",0.21); 
int angularVerticesNumber = getARGV("-angularVerticesNumber",10); 

derivativeComparaison(frequency,dipoleDistance,Rmin,Rmax,angularVerticesNumber);


