load "bem"
load "shell"
load "iovtk"
load "medit"
load "msh3"

include "computationTools.edp"
include "acousticTools.edp"
include "getARGV.idp"

verbosity = 0;
htoolEpsilon = 1e-6;
htoolEta = 1;
htoolMinclustersize = 100;
htoolMaxblocksize = 1000000;

int cutSize = 100;

func meshS getSphericMesh(real radius, real resolution)
{
    //Solve rounding issues...
    string radiusWithDecimal;
    if(radius - floor(radius) > 0)
    {
        radiusWithDecimal = radius;
    }
    else
    {
        radiusWithDecimal = radius + ".0";
    }

    string resolutionWithDecimal;
    if(resolution - floor(resolution) > 0)
    {
        resolutionWithDecimal = resolution;
    }
    else
    {
        resolutionWithDecimal = resolution + ".0";
    }

    //Load mesh
    meshS ThS("../config/meshes/sphere/S_" + radiusWithDecimal + "_" + resolutionWithDecimal + ".mesh");
    ThS = OrientNormal(ThS,unbounded=1);

    //DEBUG
    //if(mpirank==0)
    //{
    //    fespace Dummy(ThS,P0);
    //    Dummy meshSize = hTriangle;
    //    cout << "MESH SIZE" << " expected : " << resolution << " real : " << meshSize[].max << endl;
    //    cout << "VERTICES NUMBER " << ThS.nv << endl;
    //    plot(ThS);    
    //}

    return(ThS);
}

func int AcousticSL(real frequency, real radius, real resolution, real cutRadius, string studiedFunction)
{
    //Add resolution value check : For small resolutions, the final error tends to explode due to very small surfaces. We solve this issue by increasing all dimensions by a ten-fold factor.
    real scalingFactor = 1.;
    if(resolution < 0.01)
    {
        scalingFactor = 2.;
    }

    //Load mesh
    meshS ThS = getSphericMesh(radius*scalingFactor,resolution*scalingFactor);

    //Define the variational problem
    BemKernel ker("SL",k=(k(frequency)/scalingFactor));
    varf vbem(u,v) = int2dx2d(ThS)(ThS)(BEM(ker,u,v)) ;  

    //Assemble the H-Matrix
    fespace Uh(ThS,P0);
    HMatrix<complex> H = vbem(Uh,Uh);

    //Retrieve the "measurements"
    Uh<complex> measurements = inputFunction(frequency,studiedFunction);

    //When a scaling factor is used, we must simulate measurements on the original mesh !    
    if(scalingFactor != 1.)
    {
        meshS ThSInit = getSphericMesh(radius,resolution);
        fespace UhInit(ThSInit,P0);
        UhInit<complex> measurementsInit = inputFunction(frequency,studiedFunction);
        measurements[] = measurementsInit[];
    }

    //Solve the linear system
    Uh<complex> p, b;
    varf vrhs(u,v) = int2d(ThS)(measurements*v);
    b[] = vrhs(0,Uh);
    p[] = H^-1*b[];

    //Compute the numerical solution
    BemPotential Pot("SL",k=(k(frequency)/scalingFactor));
    varf vpot(u,v) = int2d(ThS)(POT(Pot,u,v));

    border circleN(t = 0, 2*pi){x=scalingFactor*cutRadius*cos(t); y=scalingFactor*cutRadius*sin(t);}
    meshL ThOutN = buildmeshL(circleN(cutSize));

    fespace UhOutN(ThOutN,P1);

    HMatrix<complex> HP = vpot(Uh,UhOutN);
    UhOutN<complex> uN;
    uN[] = HP*p[];

    //Compute the analytical solution
    border circleA(t = 0, 2*pi){x=cutRadius*cos(t); y=cutRadius*sin(t);}
    meshL ThOutA = buildmeshL(circleA(cutSize));

    fespace UhOutA(ThOutA,P1);

    UhOutA<complex> uA = inputFunction(frequency,studiedFunction);

    /*if(mpirank == 0)
    {
        UhOut u = abs(uTh);
        cout << u[].max << endl;
        int[int] Order = [0];
        string DataName = "u";
        savevtk("out.vtu", ThOut, u, dataname=DataName, order=Order);
    }*/

    //DEBUG
    if(mpirank == 0)
    {
        real[int] error(uA.n);
        for(int i = 0; i < uA.n; i++)
        {
            error[i] = abs(uA[][i] - uN[][i]);
        }
        cout << "LINF ERROR SL : " << error.max << endl;
    }

    //Fill output file
    string dirName = "BEM_" + studiedFunction + "_P0_SL";
    if(isdir("./" + dirName) == -1)
    {
        mkdir("./" + dirName);
    }
    string outputFilePath = "./" + dirName + "/output_" + frequency + "_" + resolution + "_" + radius + ".txt";
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < cutSize; i++)
    {
        file << ThOutA(i).x << ";" << ThOutA(i).y << ";" << ThOutA(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

func int AcousticCL(real frequency, real radius, real resolution, real cutRadius, string studiedFunction)
{
    //Add resolution value check : For small resolutions, the final error tends to explode due to very small surfaces. We solve this issue by increasing all dimensions by a ten-fold factor.
    real scalingFactor = 1.;
    if(resolution < 0.01)
    {
        scalingFactor = 2.;
    }

    //Load mesh
    meshS ThS = getSphericMesh(radius*scalingFactor,resolution*scalingFactor);

    //Define the variational problem
    BemKernel kerSL("SL",k=(k(frequency)/scalingFactor));
    BemKernel kerDL("DL",k=(k(frequency)/scalingFactor));
    BemKernel ker=(-(k(frequency)/scalingFactor)*1i)*kerSL+kerDL;
    varf vbem(u,v)=int2dx2d(ThS)(ThS)(BEM(ker,u,v)) + int2d(ThS)(0.5*u*v); 

    //Assemble the H-Matrix
    fespace Uh(ThS,P0);
    HMatrix<complex> H = vbem(Uh,Uh);

    //Retrieve the "measurements"
    Uh<complex> measurements = inputFunction(frequency,studiedFunction);

    //When a scaling factor is used, we must simulate measurements on the original mesh !    
    if(scalingFactor != 1.)
    {
        meshS ThSInit = getSphericMesh(radius,resolution);
        fespace UhInit(ThSInit,P0);
        UhInit<complex> measurementsInit = inputFunction(frequency,studiedFunction);
        measurements[] = measurementsInit[];
    }

    //Solve the linear system
    Uh<complex> p, b;
    varf vrhs(u,v) = int2d(ThS)(measurements*v);
    b[] = vrhs(0,Uh);
    p[] = H^-1*b[];

    //Compute the numerical solution
    BemPotential PotSL("SL",k=(k(frequency)/scalingFactor));
    varf vpotSL(u,v) = int2d(ThS)(POT(PotSL,u,v));
    BemPotential PotDL("DL",k=(k(frequency)/scalingFactor));
    varf vpotDL(u,v) = int2d(ThS)(POT(PotDL,u,v));

    border circleN(t = 0, 2*pi){x=scalingFactor*cutRadius*cos(t); y=scalingFactor*cutRadius*sin(t);}
    meshL ThOutN = buildmeshL(circleN(cutSize));

    fespace UhOutN(ThOutN,P1);

    HMatrix<complex> HPSL = vpotSL(Uh,UhOutN);
    HMatrix<complex> HPDL = vpotDL(Uh,UhOutN);
    UhOutN<complex> uN,uSL,uDL;
    uSL[] = HPSL*p[];
    uDL[] = HPDL*p[];
    uN = (-(k(frequency)/scalingFactor)*1i)*uSL + uDL;

    //Compute the analytical solution
    border circleA(t = 0, 2*pi){x=cutRadius*cos(t); y=cutRadius*sin(t);}
    meshL ThOutA = buildmeshL(circleA(cutSize));

    fespace UhOutA(ThOutA,P1);

    UhOutA<complex> uA = inputFunction(frequency,studiedFunction);

    //DEBUG
    if(mpirank == 0)
    {
        real[int] error(uA.n);
        for(int i = 0; i < uA.n; i++)
        {
            error[i] = abs(uA[][i] - uN[][i]);
        }
        cout << "LINF ERROR CL : " << error.max << endl;
    }

    //Fill output file
    string dirName = "BEM_" + studiedFunction + "_P0_CL";
    if(isdir("./" + dirName) == -1)
    {
        mkdir("./" + dirName);
    }
    string outputFilePath = "./" + dirName + "/output_" + frequency + "_" + resolution + "_" + radius + ".txt";
    ofstream file(outputFilePath);
    int np = file.precision(20);

    for (int i = 0; i < cutSize; i++)
    {
        file << ThOutA(i).x << ";" << ThOutA(i).y << ";" << ThOutA(i).z << ";" << real(uA[][i]) << ";" << imag(uA[][i]) << ";" << real(uN[][i]) << ";" << imag(uN[][i]) << endl;
    }

    return(0);
}

//MAIN

real frequency = getARGV("-frequency",100); 
real radius = getARGV("-radius",0.1); 
real resolution = getARGV("-resolution",0.05);
real cutRadius = getARGV("-cutRadius",0.5);

string studiedFunction = getARGV("-studiedFunction", "monopole");

real tmp = getARGV("-dipoleDistance",0.001);
demid = tmp;

AcousticSL(frequency,radius,resolution,cutRadius,studiedFunction);
AcousticCL(frequency,radius,resolution,cutRadius,studiedFunction);


